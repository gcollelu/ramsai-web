'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.all = exports.set = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /* global Set */


exports.isEmoji = isEmoji;
exports.extractEmoji = extractEmoji;

var _list = require('./list');

var _list2 = _interopRequireDefault(_list);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
import { readFileSync } from 'fs';
import { join } from 'path';


const fileContent = readFileSync(join(__dirname, 'emoji.txt'), 'utf8');

const all = fileContent.split('\n');
all.pop();
*/

var all = [];
var set = new Set();
for (var i = 0, chr; i < _list2.default.length; i++) {
  var _getWholeCharAndI = getWholeCharAndI(_list2.default, i);

  var _getWholeCharAndI2 = _slicedToArray(_getWholeCharAndI, 2);

  chr = _getWholeCharAndI2[0];
  i = _getWholeCharAndI2[1];

  if (chr.length > 1) {
    all.push(chr);
    set.add(chr);
  }
}

function getWholeCharAndI(str, i) {
  var code = str.charCodeAt(i);

  if (isNaN(code)) {
    return ''; // Position not found
  }
  if (code < 0xD800 || code > 0xDFFF) {
    return [str.charAt(i), i]; // Normal character, keeping 'i' the same
  }

  // High surrogate (could change last hex to 0xDB7F to treat high private
  // surrogates as single characters)
  if (0xD800 <= code && code <= 0xDBFF) {
    if (str.length <= i + 1) {
      throw 'High surrogate without following low surrogate';
    }
    var next = str.charCodeAt(i + 1);
    if (0xDC00 > next || next > 0xDFFF) {
      throw 'High surrogate without following low surrogate';
    }
    return [str.charAt(i) + str.charAt(i + 1), i + 1];
  }
  // Low surrogate (0xDC00 <= code && code <= 0xDFFF)
  if (i === 0) {
    throw 'Low surrogate without preceding high surrogate';
  }
  var prev = str.charCodeAt(i - 1);

  // (could change last hex to 0xDB7F to treat high private surrogates
  // as single characters)
  if (0xD800 > prev || prev > 0xDBFF) {
    throw 'Low surrogate without preceding high surrogate';
  }
  // Return the next character instead (and increment)
  return [str.charAt(i + 1), i + 1];
}

function isEmoji(letter) {
  return set.has(letter);
}

function extractEmoji(str) {
  var result = [];
  for (var i = 0, chr; i < str.length; i++) {
    // the current iteration and returning an array with the individual character
    // and 'i' value (only changed if a surrogate pair)

    var _getWholeCharAndI3 = getWholeCharAndI(str, i);

    var _getWholeCharAndI4 = _slicedToArray(_getWholeCharAndI3, 2);

    chr = _getWholeCharAndI4[0];
    i = _getWholeCharAndI4[1];
    if (isEmoji(chr)) {
      result.push(chr);
    }
  }
  return result;
}

exports.set = set;
exports.all = all;